{"code":"import { __decorate } from \"tslib\";\nimport { html, LitElement } from 'lit';\nimport { customElement, property } from 'lit/decorators';\nimport { localize } from '../../../localize/localize';\nimport { defaultSensorConfig, getConfigurableSensors, sensorClassToType } from '../../data/sensors';\nimport { fetchAreas, fetchSensors, saveSensor } from '../../data/websockets';\nimport { handleError, prettyPrint } from '../../helpers';\nimport { commonStyle } from '../../styles';\nimport { SubscribeMixin } from '../../subscribe-mixin';\nimport '../../components/effortlesshome-table.ts';\nlet AddSensorsCard = class AddSensorsCard extends SubscribeMixin(LitElement) {\n    constructor() {\n        super(...arguments);\n        this.addSelection = [];\n        this.areas = {};\n        this.sensors = {};\n    }\n    hassSubscribe() {\n        this._fetchData();\n        return [this.hass.connection.subscribeMessage(() => this._fetchData(), { type: 'effortlesshome_config_updated' })];\n    }\n    async _fetchData() {\n        if (!this.hass) {\n            return;\n        }\n        this.areas = await fetchAreas(this.hass);\n    }\n    async firstUpdated() {\n        this.areas = await fetchAreas(this.hass);\n        this.sensors = await fetchSensors(this.hass);\n    }\n    render() {\n        const columns = {\n            checkbox: {\n                width: '48px',\n                renderer: (item) => html `\n          <ha-checkbox\n            @change=${(e) => this.toggleSelect(e, item.id)}\n            ?checked=${this.addSelection.includes(item.id)}\n          ></ha-checkbox>\n        `,\n            },\n            icon: {\n                width: '40px',\n                renderer: (item) => html `\n          <state-badge .hass=${this.hass} .stateObj=${this.hass.states[item.id]}></state-badge>\n        `,\n            },\n            name: {\n                title: this.hass.localize('ui.components.entity.entity-picker.entity'),\n                width: '40%',\n                grow: true,\n                text: true,\n                renderer: (item) => html `\n          ${prettyPrint(item.name)}\n          <span class=\"secondary\">${item.id}</span>\n        `,\n            },\n            type: {\n                title: localize('panels.sensors.cards.add_sensors.table.type', this.hass.language),\n                width: '40%',\n                hide: this.narrow,\n                text: true,\n                renderer: (item) => item.type\n                    ? localize(`panels.sensors.cards.editor.fields.device_type.choose.${item.type}.name`, this.hass.language)\n                    : this.hass.localize('state.default.unknown'),\n            },\n        };\n        const sensorList = getConfigurableSensors(this.hass, Object.keys(this.sensors), true);\n        const tableData = sensorList.map(item => {\n            const output = Object.assign(Object.assign({}, item), { type: sensorClassToType(this.hass.states[item.id]), isSupportedType: sensorClassToType(this.hass.states[item.id]) !== undefined ? 'true' : 'false' });\n            return output;\n        });\n        return html `\n      <ha-card header=\"${localize('panels.sensors.cards.add_sensors.title', this.hass.language)}\">\n        <div class=\"card-content\">\n          ${localize('panels.sensors.cards.add_sensors.description', this.hass.language)}\n        </div>\n\n        <effortlesshome-table\n          .hass=${this.hass}\n          .columns=${columns}\n          .data=${tableData}\n          .filters=${this.getTableFilterOptions()}\n        >\n          ${localize('panels.sensors.cards.add_sensors.no_items', this.hass.language)}\n        </effortlesshome-table>\n\n        <div class=\"card-actions\">\n          <mwc-button @click=${this.addSelected} ?disabled=${this.addSelection.length == 0}>\n            ${localize('panels.sensors.cards.add_sensors.actions.add_to_alarm', this.hass.language)}\n          </mwc-button>\n        </div>\n      </ha-card>\n    `;\n    }\n    toggleSelect(ev, id) {\n        const checked = ev.target.checked;\n        this.addSelection =\n            checked && !this.addSelection.includes(id)\n                ? [...this.addSelection, id]\n                : !checked\n                    ? this.addSelection.filter(e => e != id)\n                    : this.addSelection;\n    }\n    addSelected(ev) {\n        if (!this.hass)\n            return;\n        const modeList = Object.values(this.areas)\n            .map(e => Object.entries(e.modes)\n            .filter(([, v]) => v.enabled)\n            .map(([k]) => k))\n            .reduce((a, b) => a.filter(i => b.includes(i)));\n        const data = this.addSelection\n            .map(e => defaultSensorConfig(this.hass.states[e], modeList))\n            .map(e => Object.keys(this.areas).length == 1\n            ? Object.assign(e, {\n                area: Object.keys(this.areas)[0],\n            })\n            : e)\n            .filter(e => e);\n        data.forEach(el => {\n            saveSensor(this.hass, el)\n                .catch(e => handleError(e, ev))\n                .then();\n        });\n        this.addSelection = [];\n    }\n    getTableFilterOptions() {\n        const filterConfig = {\n            isSupportedType: {\n                name: localize('panels.sensors.cards.add_sensors.actions.filter_supported', this.hass.language),\n                items: [{\n                        value: 'true',\n                        name: 'true'\n                    }],\n                value: ['true'],\n                binary: true\n            },\n        };\n        return filterConfig;\n    }\n};\nAddSensorsCard.styles = commonStyle;\n__decorate([\n    property()\n], AddSensorsCard.prototype, \"hass\", void 0);\n__decorate([\n    property()\n], AddSensorsCard.prototype, \"narrow\", void 0);\n__decorate([\n    property()\n], AddSensorsCard.prototype, \"addSelection\", void 0);\n__decorate([\n    property()\n], AddSensorsCard.prototype, \"areas\", void 0);\n__decorate([\n    property()\n], AddSensorsCard.prototype, \"sensors\", void 0);\nAddSensorsCard = __decorate([\n    customElement('add-sensors-card')\n], AddSensorsCard);\nexport { AddSensorsCard };\n","references":["/Users/jermiecullip/Documents/eh_integration/custom_components/effortlesshome/frontend/node_modules/home-assistant-js-websocket/dist/index.d.ts","/Users/jermiecullip/Documents/eh_integration/custom_components/effortlesshome/frontend/node_modules/lit/index.d.ts","/Users/jermiecullip/Documents/eh_integration/custom_components/effortlesshome/frontend/node_modules/lit/decorators.d.ts","/Users/jermiecullip/Documents/eh_integration/custom_components/effortlesshome/frontend/localize/localize.ts","/Users/jermiecullip/Documents/eh_integration/custom_components/effortlesshome/frontend/src/components/effortlesshome-table.ts","/Users/jermiecullip/Documents/eh_integration/custom_components/effortlesshome/frontend/src/data/sensors.ts","/Users/jermiecullip/Documents/eh_integration/custom_components/effortlesshome/frontend/src/data/websockets.ts","/Users/jermiecullip/Documents/eh_integration/custom_components/effortlesshome/frontend/src/helpers.ts","/Users/jermiecullip/Documents/eh_integration/custom_components/effortlesshome/frontend/src/styles.ts","/Users/jermiecullip/Documents/eh_integration/custom_components/effortlesshome/frontend/src/subscribe-mixin.ts","/Users/jermiecullip/Documents/eh_integration/custom_components/effortlesshome/frontend/src/types.ts","/Users/jermiecullip/Documents/eh_integration/custom_components/effortlesshome/frontend/src/components/effortlesshome-table.ts","/Users/jermiecullip/Documents/eh_integration/custom_components/effortlesshome/frontend/src/const.ts"]}
